получить ключ
получить позицию/ключ поиска элемента
сделать действие с использованием ключа (и объекта изменения, если есть)

getAllSorted - постоянный вид сортировки, компаратор один

виды ключа для поиска
searchKey что может быть
- индекс в массиве
- uuid
- fullName
- объект Resume
- fullName, только поиск перебором по объектам в мапе, вернуть uuid из key

Вопрос по реализации вот этой части ТЗ: "в итоге у вас в проекте должны быть два класса, реализованных на основе мапы"
В обоих классах storage это HashMap<String, Resume>, это понятно. А вот дальше подскажи пожалуйста, как правильно.

Первый класс на основе мапы - ключи мапы на основе uuid

Второй класс на основе мапы - тут с ключом возможны варианты
вариант 1 - ключем мапы является fullName (тут все просто)
вариант 2 - ключем как был, так и остался uuid, но чтобы получить searchKey надо в метод getSearchKey
передавать fullName, в методе перебором найти соответствующий этому fullName uuid и вернуть этот uuid в качестве searchKey
(тут еще нарисовывается проблема, что могут быть одинаковые имена, но при поиске мы получим ключ для первого попавшегося)

Не могу выбрать вариант реализации и честно говоря мне они оба не нравятся. Хотя это же просто HashMap, а не БД.

-------------------

searchKey это всегда объект Resume
но только во всех реалициях в методах doXXX из него будет дополнительно браться uuid (?)

-------------

Блин, реально не догоняю.

----------

Можно переписать методы класса AbstractStorage searchName, findExistSearchKey, findNotExistSearchKey, чтобы
они принимали не String uuid, а объект. Все равно они пуляют его дальше, в переопределяемые методы

Все классы придется переписать на извлечение из searchKey uuid, а вот в MapResumeStorage проверку на наличие в базе
будем делать по объекту Resume, проверяя values

